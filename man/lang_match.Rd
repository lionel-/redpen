% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/node-match.R
\name{lang_match}
\alias{lang_match}
\alias{node_match}
\title{Match patterns to a call}
\usage{
lang_match(.x, ..., .env = caller_env())

node_match(.x, ..., .env = caller_env())
}
\arguments{
\item{.x}{An expression to match.}

\item{...}{Two sided formulas with patterns on the LHS and
expressions on the RHS. If the LHS matches \code{.x}, the RHS is
evaluated.}

\item{.env}{An environment in which to evaluate the RHS. By default
the current environment.}
}
\value{
The result of evaluating the RHS of a matching pattern.
\code{NULL} if no pattern has matched \code{.x}
}
\description{
\code{node_match()} provides a flexible way of checking whether a quoted
call conforms to a pattern. It compares the call to a set of
\code{pattern ~ expression} pairs. If the LHS of a formula (e.g. a
pattern) matches, the RHS of the formula is evaluated; otherwise
the next formula is checked. Patterns support named and positional
arguments, and can involve wildcards that match anything.

If the wildcards are named, the part of the call that matched the
wildcard will be assigned under that name in the environment where
the RHS is evaluated. This technique makes it easy to provide
specific responses to different inputs.
}
\section{Pattern rules}{


A pattern typically involves one call (e.g. \code{fn(1, 2)}), and
possibly subcalls (as arguments of an outer call, e.g. \code{fn(other(), 2)}). The arguments of a call in the pattern are checked using the
following rules:
\itemize{
\item \strong{Named arguments} will match even if not in order. The patterns
\code{call(foo = 1, bar = 2)} and \code{call(bar = 2, foo = 1)} are thus
equivalent.
\item \strong{Unnamed arguments} will match only in order. The patterns
\code{call(foo, bar)} and \code{call(bar, foo)} are thus not equivalent.
\item \strong{NULL-named arguments} signal an unnamed argument that should
match even if not in order. The patterns \code{call(NULL = foo, NULL = bar)} and \code{call(NULL = bar, NULL = foo)} will both match the call
\code{call(foo, bar)}.
}

In addition, patterns can contain wildcards that will match
anything:
\itemize{
\item The \code{.} wildcard will match any argument. It can appear on the
LHS or the RHS of an argument. For instance \code{call(. = .)} will
match any argument no matter its name.
\item The \code{...} wildcard matches all remaining unmatched arguments.
\code{call(...)} will match any calls to \code{call()}, including
\code{call(foo)} or \code{call(foo, bar())}.

If you need to match an argument regardless of whether it has a
name, use the ellipsis as LHS: \code{call(... = .)}.
\item Binding wildcards with \code{.(name)}. Binding wildcards match
anything and create a reference to the matched code that you can
later refer to for further checking. For instance if you are
matching against the call \code{call(foo(bar))} with the pattern
\code{call(.(arg))}, the \code{arg} object will contain \code{foo(bar)}.
\item Eval-binding wildcards with \code{..(name)}. These wildcards work just
like binding wildcards but evaluate the matched code before
binding it to a symbol.
}

Patterns are supplied as formulas with the pattern on the left-hand
side and an expression of your choosing on the right-hand side. The
expression is evaluated only if the pattern match. It can evaluate
to a sentinel value (so you know which expression matched) or to
some checking code. If no pattern matches, the return value of is
\code{NULL}.
}

\section{\code{lang_match()} versus \code{node_match()}}{


\code{lang_match()} is just like \code{node_match()} except it standardises
the \code{.x} call and pattern calls with \code{\link[rlang:lang_standardise]{rlang::lang_standardise()}}.
Standardisation ensures that arguments are matched by position
rather than by name. Note that only function arguments positioned
before \code{...} are normalised.
}

\section{Named patterns}{


Argument names are parsed to R code. This makes it easy to supply
binding wildcards as names, e.g.\preformatted{call(`.(arg_name)` = .)
}

On the other hand it makes it more difficult to supply
non-syntactic names as you have to double quote. Either one of the
following types of double-quotes will work:\preformatted{call("`non-syntactic`" = .)
call(`\`non-syntactic\`` = .)
}
}

\section{Evaluated bindings}{


It is often useful to check the value of an argument rather than
its symbolic form. The eval-bind wildcard \code{..()} makes it easy
because it evaluates the matched argument and binds it to a
symbol. You can then refer to that symbol in the right-hand side:\preformatted{call(. = ..(foo)) ~ is.numeric(foo)
}

However you need to be a bit careful when evaluating R code this way.
\itemize{
\item First, the code should be evaluated in the right environment. If
you supplied a quosure, then it is evaluated in the quosure
environment. Otherwise, it is evaluated in \code{.env} (the caller
environment by default).
\item Secondly, the evaluated code might produce side effects, such as
a warning or an error. You might want to wrap your pattern
matching code with e.g. \code{purrr::safely()}.
}
}

\examples{

# Let's create a call to dplyr::mutate(). We'll try to match this code
# with various patterns:
call <- quote(mutate(df, weight_sq = weight^2))

# A pattern is an expression supplied as a formula. The pattern is on
# the LHS and the expression on the RHS is evaluated only if the LHS
# matches. Here the second call matches and the RHS evaluates to `2`:
node_match(call,
  mutate(df)                       ~ 1,
  mutate(df, weight_sq = weight^2) ~ 2
)

# If further arguments do not matter, use `...` in the pattern:
node_match(call,
  mutate(df)      ~ 1,
  mutate(df, ...) ~ 2
)

# The following patterns do not match because the data frame goes by
# another name. Instead of returning the RHS of a matching pattern,
# node_match() returns `NULL`:
node_match(call,
  mutate(x, ...)             ~  1,
  mutate(my_data_frame, ...) ~  2
)

# Let's use a wildcard so the data frame doesn't count. Since we have
# a match, node_match() returns the pattern RHS, `2`:
node_match(call,
  mutate(x, ...) ~ 1,
  mutate(., ...) ~ 2
)

# Wildcards also apply to names:
node_match(call,
  mutate(., weight^2)         ~ 1,
  mutate(., wrong = weight^2) ~ 2,
  mutate(., . = weight^2)     ~ 3
)

# If you want to match an argument regardless of whether it has a
# name, use the ellipsis wildcard instead:
node_match(quote(call(arg)),
  call(. = arg)   ~ 1,
  call(... = arg) ~ 2
)

# The RHS is a handy way of providing custom error messages:
fail_unnamed <- function() {
  stop("You should provide a named argument")
}
check_sq_suffix <- function(nm) {
  if (!grepl(".*_sq$", nm)) {
    stop("The new variable must end with `_sq`")
  }
  message("Alright!")
}
node_match(call,
  mutate(., .)             ~ fail_unnamed(),
  mutate(., `.(nm)` = .^2) ~ check_sq_suffix(nm),
  .                        ~ message("Try again")
)
}
